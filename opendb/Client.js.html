<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: Client.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(baseURL=(baseURL="https://printfdead.github.io/opendb").replace(/https?:\/\//i,"")).substr(baseURL.indexOf("/"))</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="PWMyTG-pHaB4S1lZs4ZEv"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="BaseClient.html">BaseClient</a></div><div class="sidebar-section-children"><a href="Client.html">Client</a></div><div class="sidebar-section-children"><a href="NodeEmitter.html">NodeEmitter</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="DI7cuYolnzxsb8nIlwznb"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#AnyArray">AnyArray</a></div><div class="sidebar-section-children"><a href="global.html#ClientOptions">ClientOptions</a></div><div class="sidebar-section-children"><a href="global.html#DecryptedOptions">DecryptedOptions</a></div><div class="sidebar-section-children"><a href="global.html#Encrypt">Encrypt</a></div><div class="sidebar-section-children"><a href="global.html#EncryptsTypes">EncryptsTypes</a></div><div class="sidebar-section-children">PredicateType.&lt;T></div><div class="sidebar-section-children"><a href="global.html#TypeResolvable">TypeResolvable</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">Client.js</h1></header><article><pre class="prettyprint source lang-js"><code>"use strict";
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
/* eslint-disable multiline-ternary */
/* eslint-disable no-delete-var */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable key-spacing */
const node_fs_1 = __importDefault(require("node:fs"));
const bson_1 = require("bson");
const uid_1 = require("uid");
const NodeEmitter_1 = require("./NodeEmitter");
const parsePath_1 = __importDefault(require("../helpers/parsePath"));
const parseSrc_1 = __importDefault(require("../helpers/parseSrc"));
const path_1 = __importDefault(require("path"));
class Client {
    /**
     * @typedef {Object} ClientOptions
     * @property {string=} Path
     */
    /**
     * @typedef {function} PredicateType&lt;T>
     * @param {T} [value=]
     * @param {number} [index=]
     * @param {T[]} [array=]
     */
    /**
     * @typedef {(object[] | string[] | number[])} AnyArray
     */
    /**
     * @typedef {(string | object | AnyArray | number)} TypeResolvable
     */
    /**
     * @constructor
     * @param {ClientOptions} Options - Put database name and path
     */
    constructor(Options) {
        this.Options = Options;
        if (typeof this.Options.Path === "undefined" || !this.Options.Path) {
            this.Options.Path = (0, parseSrc_1.default)();
        }
        else {
            this.Options.Path = path_1.default.join(...(0, parsePath_1.default)(this.Options.Path));
        }
        if (typeof this.Options.Buffer === "undefined")
            this.Options.Buffer = 512;
        this.Database = "none";
        this.Pointers = new Map();
        this.Containers = new Map();
        bson_1.BSON.setInternalBufferSize(this.Options.Buffer);
        NodeEmitter_1.Emitter.emit("start");
    }
    CheckFolders() {
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        if (!node_fs_1.default.existsSync(this.Options.Path))
            throw new Error("(ODB-01) The path you specified was not found.");
        if (!node_fs_1.default.existsSync(path_1.default.join(this.Options.Path, 'OpenDB')))
            throw new Error("(ODB-02) The database root folder not exists.");
        if (this.Database === "none")
            throw new Error("(ODB-10) The database is not configured.");
        if (!node_fs_1.default.existsSync(path_1.default.join(this.Options.Path, 'OpenDB', this.Database)))
            throw new Error("(ODB-03) This database does not exist, read https://github.com/PrintfDead/OpenDB#readme to know how to fix this error.");
    }
    /**
     * @public
     * @async
     * @description Create root folder
     * @returns {Promise&lt;this>}
     */
    async Start() {
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        if (!node_fs_1.default.existsSync(this.Options.Path))
            throw new Error("(ODB-01) The path you specified was not found.");
        if (node_fs_1.default.existsSync(path_1.default.join(this.Options.Path, 'OpenDB'))) {
            console.log("(Warn-01) The root folder already exists, nothing will be created and this function will be skipped.");
            return this;
        }
        await node_fs_1.default.promises.mkdir(path_1.default.join(this.Options.Path, 'OpenDB'), { recursive: true })
            .catch((Error) => {
            if (Error)
                NodeEmitter_1.Emitter.emit("error", Error);
        });
        return this;
    }
    /**
     * @public
     * @async
     * @param {string} Name - Database name
     * @description Create database folder
     * @returns {Promise&lt;this>}
     */
    async CreateDatabase(Name) {
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        if (!node_fs_1.default.existsSync(this.Options.Path))
            throw new Error("(ODB-01) The path you specified was not found.");
        if (!node_fs_1.default.existsSync(path_1.default.join(this.Options.Path, 'OpenDB')))
            throw new Error("(ODB-02) The database root folder not exists.");
        if (node_fs_1.default.existsSync(path_1.default.join(this.Options.Path, 'OpenDB', Name))) {
            console.log("(Warn-02) The database already exists.");
            return this;
        }
        await node_fs_1.default.promises.mkdir(path_1.default.join(this.Options.Path, 'OpenDB', Name), { recursive: true })
            .catch((Error) => {
            if (Error)
                NodeEmitter_1.Emitter.emit("error", Error);
        });
        await node_fs_1.default.promises.mkdir(path_1.default.join(this.Options.Path, 'OpenDB', Name, 'Pointers'), { recursive: true })
            .catch((Error) => {
            if (Error)
                NodeEmitter_1.Emitter.emit("error", Error);
        });
        await node_fs_1.default.promises.mkdir(path_1.default.join(this.Options.Path, 'OpenDB', Name, 'Containers'), { recursive: true })
            .catch((Error) => {
            if (Error)
                NodeEmitter_1.Emitter.emit("error", Error);
        });
        return this;
    }
    /**
     * @public
     * @param {string} Name - Database name
     * @param {BSON.DeserializeOptions} [deserializeOptions=] - Deserialize Options
     * @description Set database
     * @returns {this}
     */
    SetDatabase(Name, deserializeOptions) {
        if (typeof this.Options.Path === "string") {
            if (!node_fs_1.default.existsSync(this.Options.Path))
                throw new Error("(ODB-01) The path you specified was not found.");
            if (node_fs_1.default.existsSync(path_1.default.join(this.Options.Path, 'OpenDB'))) {
                if (!node_fs_1.default.existsSync(path_1.default.join(this.Options.Path, 'OpenDB', Name)))
                    throw new Error("(ODB-03) This database does not exist, read https://github.com/PrintfDead/OpenDB#readme to know how to fix this error.");
            }
            else {
                throw new Error("(ODB-02) The database root folder not exists.");
            }
        }
        else if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        if (this.Database === "none")
            this.Database = Name;
        else {
            this.Database = Name;
        }
        if (!deserializeOptions)
            deserializeOptions = { allowObjectSmallerThanBufferSize: true };
        else {
            if (!Object.keys(deserializeOptions).includes("allowObjectSmallerThanBufferSize") || deserializeOptions.allowObjectSmallerThanBufferSize === false) {
                deserializeOptions.allowObjectSmallerThanBufferSize = true;
            }
        }
        for (const file of node_fs_1.default.readdirSync(path_1.default.join(this.Options.Path, 'OpenDB', Name, 'Pointers'), { recursive: true })) {
            const pointerFile = node_fs_1.default.readFileSync(path_1.default.join(this.Options.Path, 'OpenDB', Name, 'Pointers', file));
            const pointer = bson_1.BSON.deserialize(pointerFile);
            const pointerDoc = {
                ID: pointer.ID,
                Reference: pointer.Reference,
                Containers: pointer.Containers
            };
            this.Pointers.clear();
            this.Pointers.set(pointer.ID, pointerDoc);
        }
        for (const file of node_fs_1.default.readdirSync(path_1.default.join(this.Options.Path, 'OpenDB', Name, 'Containers'), { recursive: true })) {
            const _file = node_fs_1.default.readFileSync(path_1.default.join(this.Options.Path, 'OpenDB', Name, 'Containers', file));
            let Document = [];
            bson_1.BSON.deserializeStream(_file, 0, 1, Document, 0, deserializeOptions);
            Document.forEach((container) => {
                if (!container.ID || !container.Tables)
                    return;
                const _container = {
                    ID: container.ID,
                    Tables: container.Tables
                };
                this.Containers.clear();
                this.Containers.set(container.ID, _container);
            });
        }
        return this;
    }
    /**
     * @public
     * @async
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * @description Create pointer
     * @returns {Promise&lt;void>}
     */
    async CreatePointer(Reference) {
        this.CheckFolders();
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        if (this.GetPointer(Reference) !== undefined) {
            console.warn("(Warn-04) A pointer with this reference already exists, the pointer will not be created.");
            return;
        }
        const IDPointer = (0, uid_1.uid)(16);
        const IDContainer = (0, uid_1.uid)(18);
        const container = {
            ID: IDContainer,
            Tables: []
        };
        const pointer = {
            ID: IDPointer,
            Reference: Reference,
            Containers: [IDContainer]
        };
        await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Pointers', IDPointer + '.bson'), bson_1.BSON.serialize(pointer))
            .catch((error) => {
            if (error)
                NodeEmitter_1.Emitter.emit("error", error);
        });
        await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', IDContainer + '.bson'), bson_1.BSON.serialize(container))
            .catch((error) => {
            if (error)
                NodeEmitter_1.Emitter.emit("error", error);
        });
        this.Pointers.set(IDPointer, pointer);
        this.Containers.set(IDContainer, container);
    }
    /**
     * @public
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * @description Get pointer
     * @returns {BSON.Document}
     */
    GetPointer(Reference) {
        this.CheckFolders();
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        let _pointer = undefined;
        this.Pointers.forEach((x) => {
            if (x.Reference === Reference) {
                _pointer = x;
            }
        });
        if (_pointer === undefined) {
            for (const file of node_fs_1.default.readdirSync(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Pointers'))) {
                const pointerFile = node_fs_1.default.readFileSync(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Pointers', file));
                const pointer = bson_1.BSON.deserialize(pointerFile);
                if (Reference === pointer.Reference) {
                    _pointer = pointer;
                }
            }
        }
        return _pointer;
    }
    /**
     * @public
     * @param {string} Container - Container ID
     * @param {BSON.DeserializeOptions} [deserializeOptions=] - Deserialize Options
     * @description Get Container
     * @returns {BSON.Document}
     */
    GetContainer(Container, deserializeOptions) {
        this.CheckFolders();
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        if (!this.Containers.get(Container)) {
            let _container = undefined;
            if (!deserializeOptions)
                deserializeOptions = { allowObjectSmallerThanBufferSize: true };
            else {
                if (!Object.keys(deserializeOptions).includes("allowObjectSmallerThanBufferSize") || deserializeOptions.allowObjectSmallerThanBufferSize === false) {
                    deserializeOptions.allowObjectSmallerThanBufferSize = true;
                }
            }
            for (const file of node_fs_1.default.readdirSync(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers'))) {
                const _file = node_fs_1.default.readFileSync(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', file));
                let Document = [];
                bson_1.BSON.deserializeStream(_file, 0, 1, Document, 0, deserializeOptions);
                Document.forEach((container) => {
                    if (!container.ID || !container.Tables)
                        return;
                    if (container.ID === Container)
                        _container = container;
                });
            }
            return _container;
        }
        else {
            return this.Containers.get(Container);
        }
    }
    /**
     * @public
     * @async
     * @param {Push} Content - Push content
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * @param {(number|string)} id - Table ID
     * @param {string} [Container=false] - Container ID
     * @description Push data to container
     * @returns {Promise&lt;void>}
     */
    async Push(Content, Reference, id, Container) {
        this.CheckFolders();
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        const pointer = this.GetPointer(Reference);
        if (pointer === undefined)
            throw new Error("(ODB-05) Pointer not found.");
        if (!Container) {
            let container = this.GetContainer(pointer.Containers[0]);
            if (!container)
                throw new Error("(ODB-06) Container not found");
            if (id === undefined) {
                const content = {
                    ID: (0, uid_1.uid)(6),
                    Content
                };
                container.Tables.push(content);
            }
            else {
                container.Tables.forEach((x) => {
                    if (x.ID === id)
                        throw new Error("(ODB-07) The id is already in use.");
                });
                const content = {
                    ID: id,
                    Content
                };
                container.Tables.push(content);
            }
            const _container = {
                ID: container.ID,
                Tables: container.Tables
            };
            this.Containers.set(container.ID, _container);
            await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', container.ID + '.bson'), bson_1.BSON.serialize(container))
                .catch((error) => {
                if (error)
                    NodeEmitter_1.Emitter.emit("error", error);
            });
        }
        else {
            let container = this.GetContainer(Container);
            if (!container)
                throw new Error("(ODB-06) Container not found");
            if (!id) {
                const content = {
                    ID: container.Tables.length == 0 ? 1 : container.Tables.length + 1,
                    Content
                };
                container.Tables.push(content);
            }
            else {
                container.Tables.forEach((x) => {
                    if (x.ID === id)
                        throw new Error("(ODB-07) The id is already in use.");
                });
                const content = {
                    ID: id,
                    Content
                };
                container.Tables.push(content);
            }
            const _container = {
                ID: container.ID,
                Tables: container.Tables
            };
            this.Containers.set(container.ID, _container);
            await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', container.ID + '.bson'), bson_1.BSON.serialize(container))
                .catch((error) => {
                if (error)
                    NodeEmitter_1.Emitter.emit("error", error);
            });
        }
    }
    /**
     * @public
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * @param {string} [Container=false] - Container ID
     * @description Add an existing container or not, to a pointer
     * @returns {void}
     */
    async AddContainer(Reference, Container) {
        this.CheckFolders();
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        const Pointer = this.GetPointer(Reference);
        const containers = [];
        if (typeof Pointer === "undefined" || !Pointer)
            throw new Error("(ODB-05) Pointer not found");
        if (typeof Container === "string") {
            if (Container.length !== 18)
                throw new Error("(ODB-09) This ID is not correct");
            if (!this.Containers.get(Container))
                throw new Error("(ODB-09) This ID is not correct");
            containers.push(Container);
        }
        else {
            const ID = (0, uid_1.uid)(18);
            containers.push(ID);
            const container = {
                ID: ID,
                Content: []
            };
            node_fs_1.default.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', ID + '.bson'), bson_1.BSON.serialize(container), (error) => {
                if (error)
                    NodeEmitter_1.Emitter.emit("error", error);
            });
        }
        const pointer = {
            ID: Pointer.ID,
            Reference: Reference,
            Containers: containers
        };
        this.Pointers.set(Pointer.ID, {
            ID: Pointer.ID,
            Reference: Reference,
            Containers: containers
        });
        await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Pointers', pointer.ID + '.bson'), bson_1.BSON.serialize(pointer))
            .catch((error) => {
            if (error)
                NodeEmitter_1.Emitter.emit("error", error);
        });
    }
    /**
     * @public
     * @async
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * @param {(number|string|null)} KeyName - Key name to search the container
     * @param {Push} KeyValue - Key value to search the container
     * @param {Push} Value - Value to define
     * @param {number} [TableId=false] - Table ID
     * @param {string} [Container=false] - Container ID
     * @description Edit a key in the container
     * @returns {Promise&lt;void>}
     */
    async Edit(Reference, KeyName, KeyValue, Value, TableId, Container) {
        this.CheckFolders();
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        const _pointer = this.GetPointer(Reference);
        if (typeof _pointer === "undefined" || !_pointer)
            throw new Error("(ODB-05) Pointer not found");
        if (typeof Container === "string") {
            if (Container.length !== 18)
                throw new Error("(ODB-09) This ID is not correct");
            const _container = this.GetContainer(Container);
            let found = false;
            if (!_container)
                throw new Error("(ODB-09) This ID is not correct");
            _container.Tables.forEach((x, i) => {
                if (typeof TableId === "number") {
                    if (x.ID === TableId) {
                        if (typeof x.Content === "string" || Array.isArray(x.Content) || typeof x.Content === "number" &amp;&amp; KeyName === null) {
                            if (x.Content === KeyValue) {
                                found = true;
                                x.Content = Value;
                            }
                        }
                        else if (typeof x.Content === "object" &amp;&amp; KeyName != null) {
                            if (x.Content[KeyName] === KeyValue) {
                                found = true;
                                x.Content[KeyName] = Value;
                            }
                        }
                    }
                }
                else {
                    if (typeof x.Content === "string" || Array.isArray(x.Content) || typeof x.Content === "number" &amp;&amp; KeyName === null) {
                        if (x.Content === KeyValue) {
                            found = true;
                            x.Content = Value;
                        }
                    }
                    else if (typeof x.Content === "object" &amp;&amp; KeyName != null) {
                        if (x.Content[KeyName] === KeyValue) {
                            found = true;
                            x.Content[KeyName] = Value;
                        }
                    }
                }
            });
            if (!found)
                throw new Error("(ODB-08) Key not found");
            let container = {
                ID: _container.ID,
                Tables: _container.Tables
            };
            this.Containers.set(container.ID, container);
            await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', container.ID + '.bson'), bson_1.BSON.serialize(container))
                .catch((error) => {
                if (error)
                    NodeEmitter_1.Emitter.emit("error", error);
            });
        }
        else {
            _pointer.Containers.forEach(async (x) => {
                if (typeof this.Options.Path === "undefined")
                    throw new Error("An error occurred and the path was not specified.");
                const _container = this.GetContainer(x);
                let found = false;
                if (!_container)
                    throw new Error("This ID is not correct");
                _container.Tables.forEach((x, i) => {
                    if (typeof TableId === "number") {
                        if (x.ID === TableId) {
                            if (typeof x.Content === "string" || Array.isArray(x.Content) || typeof x.Content === "number" &amp;&amp; KeyName === null) {
                                if (x.Content === KeyValue) {
                                    found = true;
                                    x.Content = Value;
                                }
                            }
                            else if (typeof x.Content === "object" &amp;&amp; KeyName != null) {
                                if (x.Content[KeyName] === KeyValue) {
                                    found = true;
                                    x.Content[KeyName] = Value;
                                }
                            }
                        }
                    }
                    else {
                        if (typeof x.Content === "string" || Array.isArray(x.Content) || typeof x.Content === "number" &amp;&amp; KeyName === null) {
                            if (x.Content === KeyValue) {
                                found = true;
                                x.Content = Value;
                            }
                        }
                        else if (typeof x.Content === "object" &amp;&amp; KeyName != null) {
                            if (x.Content[KeyName] === KeyValue) {
                                found = true;
                                x.Content[KeyName] = Value;
                            }
                        }
                    }
                });
                if (!found)
                    throw new Error("(ODB-08) Key not found");
                let container = {
                    ID: _container.ID,
                    Tables: _container.Tables
                };
                this.Containers.set(container.ID, container);
                await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', container.ID + '.bson'), bson_1.BSON.serialize(container))
                    .catch((error) => {
                    if (error)
                        NodeEmitter_1.Emitter.emit("error", error);
                });
            });
        }
    }
    /**
     * @public
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * @param {PredicateType&lt;T>} predicate - Predicate to find data
     * @param {string} [Container=false] - Container ID
     * @returns {(ContainerTable | undefined)}
     */
    FindByPredicate(Reference, predicate, Container) {
        const pointer = this.GetPointer(Reference);
        if (!pointer)
            throw new Error("(ODB-05) Pointer not found");
        if (!Container) {
            const container = this.GetContainer(pointer.Containers[0]);
            if (!container)
                throw new Error("(ODB-06) Container not found");
            return container.Tables.find(predicate);
        }
        else {
            const container = this.GetContainer(Container);
            if (!container)
                throw new Error("(ODB-06) Container not found");
            return container.Tables.find(predicate);
        }
    }
    /**
     * @public
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * @param {PredicateType&lt;T>} predicate - Predicate to filter data
     * @param {string} [Container=false] - Container ID
     * @returns {(ContainerTable[] | undefined)}
     */
    Filter(Reference, predicate, Container) {
        const pointer = this.GetPointer(Reference);
        if (!pointer)
            throw new Error("(ODB-05) Pointer not found");
        if (!Container) {
            const container = this.GetContainer(pointer.Containers[0]);
            if (!container)
                throw new Error("(ODB-06) Container not found");
            return container.Tables.filter(predicate);
        }
        else {
            const container = this.GetContainer(Container);
            if (!container)
                throw new Error("(ODB-06) Container not found");
            return container.Tables.filter(predicate);
        }
    }
    /**
     * @public
     * @async
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * @param {(string | number | null)} KeyName - Key name to search the container
     * @param {Push} KeyValue - Key value to search the container
     * @param {string} [Container=false] - Container ID
     * @description Search table by a key
     * @returns {(ContainerTable | undefined)}
     */
    Find(Reference, KeyName, KeyValue, Container) {
        this.CheckFolders();
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        const _pointer = this.GetPointer(Reference);
        if (typeof _pointer === "undefined" || !_pointer)
            throw new Error("(ODB-05) Pointer not found");
        if (typeof Container === "string") {
            if (Container.length !== 18)
                throw new Error("(ODB-09) This ID is not correct");
            const _container = this.GetContainer(Container);
            let found = false;
            let table;
            if (!_container)
                throw new Error("(ODB-09) This ID is not correct");
            _container.Tables.forEach((x, i) => {
                if (typeof x.Content === "string" || Array.isArray(x.Content) || typeof x.Content === "number" &amp;&amp; KeyName === null) {
                    if (x.Content === KeyValue) {
                        found = true;
                        table = x;
                    }
                }
                else if (typeof x.Content === "object" &amp;&amp; KeyName != null) {
                    if (x.Content[KeyName] === KeyValue) {
                        found = true;
                        table = x;
                    }
                }
            });
            if (!found || !table)
                throw new Error("(ODB-08) Key not found");
            return table;
        }
        else {
            let table;
            _pointer.Containers.forEach(async (x) => {
                const _container = this.GetContainer(x);
                let found = false;
                if (!_container)
                    throw new Error("This ID is not correct");
                _container.Tables.forEach((x, i) => {
                    if (typeof x.Content === "string" || Array.isArray(x.Content) || typeof x.Content === "number" &amp;&amp; KeyName === null) {
                        if (x.Content === KeyValue) {
                            found = true;
                            table = x;
                        }
                    }
                    else if (typeof x.Content === "object" &amp;&amp; KeyName != null) {
                        if (x.Content[KeyName] === KeyValue) {
                            found = true;
                            table = x;
                        }
                    }
                });
                if (!found || !table)
                    throw new Error("(ODB-08) Key not found");
            });
            return table;
        }
    }
    /**
     * @public
     * @async
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * * @param {number} TableId - TableId ID
     * @param {string} [Container=false] - Container ID
     * @description Get table by a table id
     * @returns {(ContainerTable | undefined)}
     */
    Get(Reference, TableId, Container) {
        this.CheckFolders();
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        const _pointer = this.GetPointer(Reference);
        if (typeof _pointer === "undefined" || !_pointer)
            throw new Error("(ODB-05) Pointer not found");
        if (typeof Container === "string") {
            if (Container.length !== 18)
                throw new Error("(ODB-09) This ID is not correct");
            const _container = this.GetContainer(Container);
            let found = false;
            let table;
            if (!_container)
                throw new Error("(ODB-09) This ID is not correct");
            _container.Tables.forEach((x, i) => {
                if (x.ID === TableId) {
                    found = true;
                    table = x;
                }
            });
            if (!found || !table)
                throw new Error("(ODB-08) Key not found");
            return table;
        }
        else {
            let table;
            _pointer.Containers.forEach(async (x) => {
                const _container = this.GetContainer(x);
                let found = false;
                if (!_container)
                    throw new Error("This ID is not correct");
                _container.Tables.forEach((x, i) => {
                    if (x.ID === TableId) {
                        found = true;
                        table = x;
                    }
                });
                if (!found || !table)
                    throw new Error("(ODB-08) Key not found");
            });
            return table;
        }
    }
    /**
     * @public
     * @async
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * @param {number} TableId - Table ID
     * @param {string} [Container=false] - Container ID
     * @description Delete Table
     * @returns {Promise&lt;void>}
     */
    async DeleteTable(Reference, TableId, Container) {
        this.CheckFolders();
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        const pointer = this.GetPointer(Reference);
        if (pointer === undefined)
            throw new Error("(ODB-05) Pointer not found.");
        let container = undefined;
        if (Container === undefined) {
            let found = false;
            pointer.Containers.forEach((x) => {
                const _container = this.GetContainer(x);
                if (_container === undefined)
                    throw new Error("(ODB-06) Container not found");
                _container.Tables.forEach((x, i) => {
                    if (x.ID === TableId) {
                        found = true;
                        delete _container.Tables[i];
                    }
                });
                container = {
                    ID: _container.ID,
                    Tables: _container.Tables
                };
            });
            if (!found)
                throw new Error("(ODB-08) Key not found");
            this.Containers.set(container.ID, container);
            await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', container.ID + '.bson'), bson_1.BSON.serialize(container))
                .catch((error) => {
                if (error)
                    NodeEmitter_1.Emitter.emit("error", error);
            });
        }
        else {
            const _container = this.GetContainer(Container);
            let found = false;
            if (_container === undefined)
                throw new Error("(ODB-06) Container not found");
            _container.Tables.forEach((x, i) => {
                if (x.ID === TableId) {
                    found = true;
                    delete _container.Tables[i];
                }
            });
            container = {
                ID: _container.ID,
                Tables: _container.Tables
            };
            if (!found)
                throw new Error("(ODB-08) Key not found");
            this.Containers.set(container.ID, container);
            await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', container.ID + '.bson'), bson_1.BSON.serialize(container))
                .catch((error) => {
                if (error)
                    NodeEmitter_1.Emitter.emit("error", error);
            });
        }
    }
    /**
     * @public
     * @async
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * @param {(string | number | null)} KeyName - Key name to search the container
     * @param {Push} KeyValue - Key value to search the container
     * @param {string} [Container=false] - Container ID
     * @description Delete Table by Key
     * @returns {Promise&lt;void>}
     */
    async DeleteTableByKey(Reference, KeyName, KeyValue, Container) {
        this.CheckFolders();
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        const pointer = this.GetPointer(Reference);
        if (pointer === undefined)
            throw new Error("(ODB-05) Pointer not found.");
        let container = undefined;
        if (Container === undefined) {
            let found = false;
            pointer.Containers.forEach((x) => {
                const _container = this.GetContainer(x);
                if (_container === undefined)
                    throw new Error("(ODB-06) Container not found");
                _container.Tables.forEach((x, i) => {
                    if (typeof x.Content === "string" || Array.isArray(x.Content) || typeof x.Content === "number" &amp;&amp; KeyName === null) {
                        if (x.Content === KeyValue) {
                            found = true;
                            delete _container.Tables[i];
                        }
                    }
                    else if (typeof x.Content === "object" &amp;&amp; KeyName != null) {
                        if (x.Content[KeyName] === KeyValue) {
                            found = true;
                            delete _container.Tables[i];
                        }
                    }
                });
                container = {
                    ID: _container.ID,
                    Tables: _container.Tables
                };
            });
            if (!found)
                throw new Error("(ODB-08) Key not found");
            this.Containers.set(container.ID, container);
            await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', container.ID + '.bson'), bson_1.BSON.serialize(container))
                .catch((error) => {
                if (error)
                    NodeEmitter_1.Emitter.emit("error", error);
            });
        }
        else {
            const _container = this.GetContainer(Container);
            let found = false;
            if (_container === undefined)
                throw new Error("(ODB-06) Container not found");
            _container.Tables.forEach((x, i) => {
                if (typeof x.Content === "string" || Array.isArray(x.Content) || typeof x.Content === "number" &amp;&amp; KeyName === null) {
                    if (x.Content === KeyValue) {
                        found = true;
                        delete _container.Tables[i];
                    }
                }
                else if (typeof x.Content === "object" &amp;&amp; KeyName != null) {
                    if (x.Content[KeyName] === KeyValue) {
                        found = true;
                        delete _container.Tables[i];
                    }
                }
            });
            container = {
                ID: _container.ID,
                Tables: _container.Tables
            };
            if (!found)
                throw new Error("(ODB-08) Key not found");
            this.Containers.set(container.ID, container);
            await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', container.ID + '.bson'), bson_1.BSON.serialize(container))
                .catch((error) => {
                if (error)
                    NodeEmitter_1.Emitter.emit("error", error);
            });
        }
    }
    /**
     * @public
     * @async
     * @param {(string|number)} Reference - Reference to find the pointer easier
     * @param {(number|string|null)} KeyName - Key name to search the container
     * @param {Push} KeyValue - Key value to search the container
     * @param {string} [Container=false] - Container ID
     * @description Delete Key
     * @returns {Promise&lt;void>}
     */
    async DeleteKey(Reference, KeyName, KeyValue, Container) {
        this.CheckFolders();
        if (typeof this.Options.Path === "undefined")
            throw new Error("An error occurred and the path was not specified.");
        const pointer = this.GetPointer(Reference);
        if (pointer === undefined)
            throw new Error("(ODB-05) Pointer not found.");
        let container = undefined;
        if (Container === undefined) {
            let found = true;
            pointer.Containers.forEach((x) => {
                const _container = this.GetContainer(x);
                if (_container === undefined)
                    throw new Error("(ODB-06) Container not found");
                _container.Tables.forEach((x) => {
                    if (typeof x.Content === "string" || Array.isArray(x.Content) || typeof x.Content === "number" &amp;&amp; KeyName === null) {
                        if (x.Content === KeyValue) {
                            found = true;
                            delete x.Content;
                        }
                    }
                    else if (typeof x.Content === "object" &amp;&amp; KeyName != null) {
                        if (x.Content[KeyName] === KeyValue) {
                            found = true;
                            delete x.Content[KeyName];
                        }
                    }
                });
                container = {
                    ID: _container.ID,
                    Tables: _container.Tables
                };
            });
            if (!found)
                throw new Error("(ODB-08) Key not found");
            this.Containers.set(container.ID, container);
            await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', container.ID + '.bson'), bson_1.BSON.serialize(container))
                .catch((error) => {
                if (error)
                    NodeEmitter_1.Emitter.emit("error", error);
            });
        }
        else {
            const _container = this.GetContainer(Container);
            let found = false;
            if (_container === undefined)
                throw new Error("(ODB-06) Container not found");
            _container.Tables.forEach((x) => {
                if (typeof x.Content === "string" || Array.isArray(x.Content) || typeof x.Content === "number" &amp;&amp; KeyName === null) {
                    if (x.Content === KeyValue) {
                        found = true;
                        delete x.Content;
                    }
                }
                else if (typeof x.Content === "object" &amp;&amp; KeyName != null) {
                    if (x.Content[KeyName] === KeyValue) {
                        found = true;
                        delete x.Content[KeyName];
                    }
                }
            });
            container = {
                ID: _container.ID,
                Tables: _container.Tables
            };
            if (!found)
                throw new Error("(ODB-08) Key not found");
            this.Containers.set(container.ID, container);
            await node_fs_1.default.promises.writeFile(path_1.default.join(this.Options.Path, 'OpenDB', this.Database, 'Containers', container.ID + '.bson'), bson_1.BSON.serialize(container))
                .catch((error) => {
                if (error)
                    NodeEmitter_1.Emitter.emit("error", error);
            });
        }
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="PWMyTG-pHaB4S1lZs4ZEv"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="BaseClient.html">BaseClient</a></div><div class="sidebar-section-children"><a href="Client.html">Client</a></div><div class="sidebar-section-children"><a href="NodeEmitter.html">NodeEmitter</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="DI7cuYolnzxsb8nIlwznb"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#AnyArray">AnyArray</a></div><div class="sidebar-section-children"><a href="global.html#ClientOptions">ClientOptions</a></div><div class="sidebar-section-children"><a href="global.html#DecryptedOptions">DecryptedOptions</a></div><div class="sidebar-section-children"><a href="global.html#Encrypt">Encrypt</a></div><div class="sidebar-section-children"><a href="global.html#EncryptsTypes">EncryptsTypes</a></div><div class="sidebar-section-children">PredicateType.&lt;T></div><div class="sidebar-section-children"><a href="global.html#TypeResolvable">TypeResolvable</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>